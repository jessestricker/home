#! /usr/bin/env -S uv run --script
#
# /// script
# requires-python = ">=3.14"
# dependencies = [
#     "click==8.3.1",
# ]
# ///

import errno
import subprocess
from collections.abc import Generator
from pathlib import Path
from typing import Literal, assert_never

import click

HOME_DIR = Path.home()
DOTFILES_DIR = Path(__file__).resolve().parent.parent.parent

IGNORED_PATHS = [
    "LICENSE",
    "README.md",
]


def is_ignored_path(path: Path) -> bool:
    return any(path.full_match(pattern) for pattern in IGNORED_PATHS)


def iter_files_git() -> Generator[Path]:
    result = subprocess.run(
        [
            "git",
            "ls-files",
            "--cached",
            "--modified",
            "--others",
            "--deduplicate",
            "--exclude-standard",
        ],
        capture_output=True,
        cwd=DOTFILES_DIR,
        check=True,
        encoding="utf-8",
    )

    files = result.stdout.splitlines()
    files = (Path(file) for file in files)
    files = (file for file in files if not is_ignored_path(file))
    return files


type FileStatus = Literal["MISSING", "CONFLICT", "SYNCED"]


def get_file_status(relative_path: Path) -> FileStatus:
    home_file = HOME_DIR / relative_path

    try:
        home_file_target = home_file.readlink()
    except FileNotFoundError:
        return "MISSING"
    except OSError as exc:
        if exc.errno == errno.EINVAL:
            return "CONFLICT"
        raise

    dotfiles_file = DOTFILES_DIR / relative_path
    if home_file_target != dotfiles_file:
        return "CONFLICT"

    return "SYNCED"


def print_file_status(relative_path: Path, status: FileStatus) -> None:
    click.echo(f"{relative_path} - ", nl=False)
    match status:
        case "MISSING":
            click.secho(status, fg="blue", bold=True)
        case "CONFLICT":
            click.secho(status, fg="red", bold=True)
        case "SYNCED":
            click.secho(status, fg="green", bold=True)
        case _:
            assert_never(status)


def sync_file(relative_path: Path) -> bool:
    status = get_file_status(relative_path)

    if status == "CONFLICT":
        print_file_status(relative_path, status)
        return False

    if status == "SYNCED":
        return True

    dotfiles_file = DOTFILES_DIR / relative_path
    home_file = HOME_DIR / relative_path
    home_file.parent.mkdir(parents=True, exist_ok=True)
    home_file.symlink_to(dotfiles_file)
    return True


@click.group()
def main() -> None:
    pass


@main.command()
def list_cmd() -> None:
    for relative_path in iter_files_git():
        status = get_file_status(relative_path)
        print_file_status(relative_path, status)


@main.command()
@click.pass_context
def sync_cmd(ctx: click.Context) -> None:
    all_succeeded = True
    for relative_path in iter_files_git():
        if not sync_file(relative_path):
            all_succeeded = False

    if not all_succeeded:
        ctx.exit(1)


@main.command()
@click.argument(
    "file",
    type=click.Path(
        exists=True,
        dir_okay=False,
        resolve_path=True,
        path_type=Path,
    ),
)
def add_cmd(file: Path) -> None:
    relative_path = file.relative_to(HOME_DIR)
    dotfiles_file = DOTFILES_DIR / relative_path

    dotfiles_file.parent.mkdir(parents=True, exist_ok=True)
    file.move(dotfiles_file)
    file.symlink_to(dotfiles_file)


if __name__ == "__main__":
    main()
